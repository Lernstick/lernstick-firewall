#! /bin/sh
### BEGIN INIT INFO
# Provides:          lernstick-firewall
# Required-Start:    $network $remote_fs
# Required-Stop:     $network $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Lernstick Firewall
# Description:       Simple firewall for the Lernstick
### END INIT INFO

# Author: Gaudenz Steinlin <gaudenz@debian.org>

# Do NOT "set -e"

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/sbin:/usr/sbin:/bin:/usr/bin
DESC="Lernstick Firewall"
NAME=lernstick-firewall
TINYPROXY=/usr/sbin/tinyproxy
FIREWALL=/usr/sbin/lernstick-firewall
SCRIPTNAME=/etc/init.d/$NAME

# Exit if the package is not installed
[ -x "$TINYPROXY" ] || exit 0
[ -x "$FIREWALL" ] || exit 0

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.2-14) to ensure that this file is present
# and status_of_proc is working.
. /lib/lsb/init-functions

# assert pidfile directory and permissions
. /etc/lernstick-firewall/lernstick-firewall.conf

if [ -r "$PROXY_CONF" ]; then
    USER=$(grep    -i '^User[[:space:]]'    "$PROXY_CONF" | awk '{print $2}')
    GROUP=$(grep   -i '^Group[[:space:]]'   "$PROXY_CONF" | awk '{print $2}')
    PIDFILE=$(grep -i '^PidFile[[:space:]]' "$PROXY_CONF" | awk '{print $2}' |\
              sed -e 's/"//g')
    PIDDIR=`dirname "$PIDFILE"`
else
    log_action_msg "Tinyproxy configuration not found. Not starting lernstick-firewall"
    exit 1
fi

if [ "$1" != "stop" ]; then
    if [ -n "$PIDDIR" -a "$PIDDIR" != "/var/run" ]; then
        if [ ! -d "$PIDDIR" ]; then
            mkdir "$PIDDIR"
        fi
        if [ "$USER" ]; then
            chown "$USER" "$PIDDIR"
        fi
        if [ "$GROUP" ]; then
            chgrp "$GROUP" "$PIDDIR"
        fi
    fi
fi

#
# Function that starts the daemon/service
#
do_start()
{
    # Return
    #   0 if daemon has been started
    #   1 if daemon was already running
    #   2 if daemon could not be started

    RETVAL="0"

    # start firewall rules
    [ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "iptables"
    ${FIREWALL} start || RETVAL="2"

    # start tinyproxy if it's not running
    if start-stop-daemon --start --quiet  --exec $TINYPROXY --pidfile $PIDFILE --test > /dev/null ; then
        [ "$VERBOSE" != no ] && log_progress_msg "tinyproxy"
        start-stop-daemon --start --quiet --exec $TINYPROXY --pidfile $PIDFILE -- -c $PROXY_CONF || RETVAL="2"
    fi

    case "$RETVAL" in
        0|1)
            [ "$VERBOSE" != no ] && log_end_msg 0
            ;;
        2)
            [ "$VERBOSE" != no ] && log_end_msg 1
            ;;
    esac

    return "$RETVAL"
}

#
# Function that stops the daemon/service
#
do_stop()
{
    # Return
    #   0 if daemon has been stopped
    #   1 if daemon was already stopped
    #   2 if daemon could not be stopped
    #   other if a failure occurred

    RETVAL="0"

    # stop firewall rules
    [ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "iptables"
    ${FIREWALL} stop || RETVAL="2"

    [ "$VERBOSE" != no ] && log_progress_msg "tinyproxy"
    start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $PIDFILE --name tinyproxy || RETVAL="2"

    case "$RETVAL" in
        0|1)
            [ "$VERBOSE" != no ] && log_end_msg 0

            # If tinyproxy had to be KILLed it might not have removed it's pidfile
            rm -f $PIDFILE
    
            ;;
        2)
            [ "$VERBOSE" != no ] && log_end_msg 1
            ;;
    esac

    return "$RETVAL"
}

#
# Function to reload the firewall
#
do_reload() 
{
    RETVAL="0"

    log_daemon_msg "Reloading $DESC" "iptables"
    ${FIREWALL} reload || RETVAL="2"

    log_progress_msg "tinyproxy"
    start-stop-daemon --stop --signal 1 --quiet --pidfile $PIDFILE --name tinyproxy || RETVAL="2"

    case "$RETVAL" in
        0|1)
            [ "$VERBOSE" != no ] && log_end_msg 0
            ;;
        2)
            [ "$VERBOSE" != no ] && log_end_msg 1
            ;;
    esac

    return "$RETVAL"
}

case "$1" in
    start)
        do_start
        ;;
    stop)
        do_stop
        ;;
    status)
        status_of_proc "$DAEMON" "$NAME" && exit 0 || exit $?
        ;;
    reload|force-reload)
        do_reload
        ;;
    restart)
        do_stop
        case "$?" in
            0|1)
                do_start
                ;;
        esac
        ;;
    *)
        echo "Usage: $SCRIPTNAME {start|stop|status|restart|reload}" >&2
        exit 3
        ;;
esac

:
